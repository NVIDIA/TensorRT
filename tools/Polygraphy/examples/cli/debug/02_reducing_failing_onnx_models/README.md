# Reducing Failing ONNX Models

## Introduction

When a model fails for any reason (for example, an accuracy issue in TensorRT) it is often
useful to reduce it to the smallest possible subgraph that triggers the failure. That makes
it easier to pinpoint the cause of the failure.

One approach to doing so is to generate successively smaller subgraphs of the original ONNX model.
At each iteration, we can check whether the subgraph works or is still failing; once we have a working
subgraph, we know that the subgraph generated by the previous iteration is the smallest failing
subgraph.

The `debug reduce` subtool allows us to automate this process. The tool offers multiple strategies to
reduce the model: `bisect` operates in O(log(N)) time, while `linear` operates in O(N) time but may
lead to smaller models. A good compromise is to use `bisect` on the original model, then further reduce
the result using `linear`. This is the approach that will be outlined in this example.

For more details on how the `debug` tools work, see [here](polygraphy/tools/debug/).


## Running The Example

For the sake of this example, we'll assume our model (`./model.onnx`) has accuracy issues
in TensorRT. Since the model actually does work in TensorRT (please report a bug if not!),
we'll outline the commands that you would normally run followed by commands you can run to
simulate a failure to get a feel for how the tool looks in practice.

Our simulated failures will trigger whenever there's a `Mul` node in the model:

![./model.png](./model.png)

Hence, the final reduced model should contain just the `Mul` node (since the other nodes don't cause a failure).

1. To start with, let's assume ONNX-Runtime gives us correct outputs. We'll start by generating golden
    values for every tensor in the network. We'll also save the inputs we use:

    ```bash
    polygraphy run model.onnx --onnxrt \
        --save-inputs inputs.json \
        --onnx-outputs mark all --save-outputs layerwise_golden.json
    ```

    Then we'll combine the inputs and layerwise outputs into a single layerwise inputs file
    using the `data to-input` subtool (we'll see why this is necessary in the next step):

    ```bash
    polygraphy data to-input inputs.json layerwise_golden.json -o layerwise_inputs.json
    ```


2. Next, we'll use `debug reduce` in `bisect` mode:

    ```bash
    polygraphy debug reduce model.onnx -o initial_reduced.onnx --mode=bisect \
        --check polygraphy run polygraphy_debug.onnx --trt \
                --load-inputs layerwise_inputs.json --load-outputs layerwise_golden.json
    ```

    Similar to the other `debug` subtools, `debug reduce` generates an intermediate artifact each iteration
    (`./polygraphy_debug.onnx` by default). In order for `debug reduce` to determine whether the model
    fails or passes, we need to provide a `--check` command. Since we're looking into an accuracy issue,
    we can use `polygraphy run` to compare against our golden outputs from before.

    *NOTE: We must provide the layerwise inputs file, since otherwise, `polygraphy run`*
        *would generate new inputs for the subgraph tensors, which may not match the values those tensors*
        *had when we generated our golden data. An alternative approach is to run the reference implementation*
        *(ONNX-Runtime here) during each iteration of `debug reduce` rather than ahead of time.*

    Sometimes, the reduced model may fail in a different way than the original; generally, we're more interested
    in the original failure, and so we would like to ignore other types of failures. The `debug` subtools provide
    multiple ways of doing so. For example, with `--fail-regex` set, `debug reduce` counts a failure only
    when some part of the output (on either `stdout` or `stderr`) from the `--check` command matches the specified regular expression(s).

    Finally, the reduced model will be written to `initial_reduced.onnx`, as specified by the `-o` option.

    *TIP: It can also be useful to write out the first passing subgraph to compare it to the reduced failing model.*
        *To do so, you can use `--min-good <path>`.*

    **To Simulate A Failure:** We can use `polygraphy inspect model` in conjunction with `--fail-regex` to trigger
    a failure whenever the model contains a `Mul` node:

    ```bash
    polygraphy debug reduce model.onnx -o initial_reduced.onnx --mode=bisect \
        --fail-regex "Op: Mul" \
        --check polygraphy inspect model polygraphy_debug.onnx --mode=basic
    ```

3. **[Optional]** As a sanity check, we can inspect our reduced model to ensure that it does contain the `Mul` node:

    ```bash
    polygraphy inspect model initial_reduced.onnx --mode=basic
    ```

4. Since we used `bisect` mode in the previous step, the model may not be as minimal as it could be.
    To further refine it, we'll run `debug reduce` again in `linear` mode:

    ```bash
    polygraphy debug reduce initial_reduced.onnx -o final_reduced.onnx --mode=linear \
        --check polygraphy run polygraphy_debug.onnx --trt \
                --load-inputs layerwise_inputs.json --load-outputs layerwise_golden.json
    ```

    **To Simulate A Failure:** We'll use the same technique as before:

    ```bash
    polygraphy debug reduce initial_reduced.onnx -o final_reduced.onnx --mode=linear \
        --fail-regex "Op: Mul" \
        --check polygraphy inspect model polygraphy_debug.onnx --mode=basic
    ```

5. **[Optional]** At this stage, `final_reduced.onnx` should contain just the failing node - the `Mul`.
    We can verify this with `inspect model`:

    ```bash
    polygraphy inspect model final_reduced.onnx --mode=basic
    ```


## A Note On Models With Dynamic Input Shapes

For models with dynamic input shapes, we may not always know the shapes of intermediate
tensors in the model. Thus, when we check subgraphs, our `--check` command may end up using
incorrect tensor shapes.

To get around this, you can specify fixed shapes to use for the inputs of the original model
with `--model-input-shapes`. `debug reduce` will use ONNX shape inference to infer the shapes
of the intermediate tensors based on these. The `polygraphy_debug.onnx` subgraph generated during
each iteration will then have fixed shapes.

In case there's a problem with ONNX shape inference, you can set `--force-fallback-shape-inference`
to infer shapes using ONNX-Runtime instead.

Alternatively, you can use `--no-reduce-inputs` so that the model inputs are not modified.
The `polygraphy_debug.onnx` subgraph generated during each iteration will always use the inputs
of the original model; only layers from the end will be removed.
